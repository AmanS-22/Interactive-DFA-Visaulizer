<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFA Transition Diagram Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .input-section, .output-section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select, button, textarea {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        #diagram-container {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
            margin-top: 20px;
            position: relative;
            overflow: auto;
            background-color: #f9f9f9;
        }
        .state {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #f8f8f8;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            user-select: none;
            z-index: 10;
        }
        .state.final {
            border: double 4px #333;
        }
        .state.initial::before {
            content: "";
            position: absolute;
            left: -25px;
            top: 15px;
            width: 20px;
            height: 2px;
            background-color: #333;
        }
        .state.initial::after {
            content: "";
            position: absolute;
            left: -25px;
            top: 10px;
            width: 10px;
            height: 10px;
            border-right: 2px solid #333;
            border-bottom: 2px solid #333;
            transform: rotate(-45deg);
        }
        .transition-label {
            position: absolute;
            background-color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            border: 1px solid #eee;
            z-index: 15;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .controls button {
            flex: 1;
        }
        .error {
            color: red;
            margin-top: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .null-transition {
            stroke-dasharray: 5,5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DFA Transition Diagram Tool</h1>

        <div class="input-section">
            <h2>DFA Specification</h2>
            <div class="form-group">
                <label for="states">States (comma separated):</label>
                <input type="text" id="states" placeholder="e.g. q0,q1,q2" value="q0,q1,q2">
            </div>
            <div class="form-group">
                <label for="alphabet">Alphabet (comma separated):</label>
                <input type="text" id="alphabet" placeholder="e.g. 0,1" value="0,1">
            </div>
            <div class="form-group">
                <label for="transitions">Transitions (one per line, format: fromState,inputSymbol,toState):</label>
                <textarea id="transitions" rows="5">q0,0,q1
q0,1,q0
q1,0,q1
q1,1,q2
q2,0,q1
q2,1,q0</textarea>
            </div>
            <div class="form-group">
                <label for="initialState">Initial State:</label>
                <select id="initialState">
                    <option value="q0" selected>q0</option>
                    <option value="q1">q1</option>
                    <option value="q2">q2</option>
                </select>
            </div>
            <div class="form-group">
                <label for="finalStates">Final States (comma separated):</label>
                <input type="text" id="finalStates" placeholder="e.g. q2" value="q2">
            </div>
            <button id="generate-btn">Generate Diagram</button>
            <div id="error-message" class="error"></div>
        </div>

        <div class="output-section">
            <h2>Transition Diagram</h2>
            <div class="controls">
                <button id="arrange-btn">Arrange States</button>
                <button id="clear-btn">Clear Diagram</button>
            </div>
            <div id="diagram-container"></div>

            <h2>Transition Table</h2>
            <div id="transition-table"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const statesInput = document.getElementById('states');
            const alphabetInput = document.getElementById('alphabet');
            const transitionsInput = document.getElementById('transitions');
            const initialStateSelect = document.getElementById('initialState');
            const finalStatesInput = document.getElementById('finalStates');
            const generateBtn = document.getElementById('generate-btn');
            const arrangeBtn = document.getElementById('arrange-btn');
            const clearBtn = document.getElementById('clear-btn');
            const diagramContainer = document.getElementById('diagram-container');
            const transitionTableDiv = document.getElementById('transition-table');
            const errorMessage = document.getElementById('error-message');

            let states = [];
            let alphabet = [];
            let transitions = [];
            let initialState = '';
            let finalStates = [];
            let stateElements = {};
            let isDragging = false;
            let dragStartX, dragStartY;
            let draggedElement = null;

            generateBtn.addEventListener('click', generateDiagram);
            arrangeBtn.addEventListener('click', arrangeStates);
            clearBtn.addEventListener('click', clearDiagram);

            function generateDiagram() {
                errorMessage.textContent = '';
                try {
                    // Parse inputs
                    states = statesInput.value.split(',').map(s => s.trim()).filter(s => s);
                    alphabet = alphabetInput.value.split(',').map(s => s.trim()).filter(s => s);
                    
                    const transitionLines = transitionsInput.value.split('\n').filter(line => line.trim());
                    transitions = transitionLines.map(line => {
                        const parts = line.split(',').map(part => part.trim());
                        if (parts.length !== 3) {
                            throw new Error(`Invalid transition format: ${line}. Use "fromState,inputSymbol,toState"`);
                        }
                        return { from: parts[0], input: parts[1], to: parts[2] };
                    });
                    
                    initialState = initialStateSelect.value;
                    finalStates = finalStatesInput.value.split(',').map(s => s.trim()).filter(s => s);

                    // Validate inputs
                    if (states.length === 0) throw new Error('At least one state is required');
                    if (alphabet.length === 0) throw new Error('At least one alphabet symbol is required');
                    if (transitions.length === 0) throw new Error('At least one transition is required');
                    if (!initialState) throw new Error('Initial state is required');
                    
                    for (const t of transitions) {
                        if (!states.includes(t.from)) throw new Error(`State ${t.from} in transition is not defined`);
                        if (!states.includes(t.to)) throw new Error(`State ${t.to} in transition is not defined`);
                        if (!alphabet.includes(t.input)) {
                            throw new Error(`Symbol ${t.input} in transition is not in alphabet`);
                        }
                    }
                    
                    if (!states.includes(initialState)) throw new Error(`Initial state ${initialState} is not defined`);
                    for (const fs of finalStates) {
                        if (!states.includes(fs)) throw new Error(`Final state ${fs} is not defined`);
                    }

                    // Generate visualization
                    clearDiagram();
                    createStateElements();
                    drawTransitions();
                    generateTransitionTable();
                } catch (error) {
                    errorMessage.textContent = error.message;
                }
            }

            function createStateElements() {
                stateElements = {};
                const containerWidth = diagramContainer.clientWidth;
                const containerHeight = diagramContainer.clientHeight;
                const centerX = containerWidth / 2;
                const centerY = containerHeight / 2;
                const radius = Math.min(containerWidth, containerHeight) * 0.35;
                const angleStep = (2 * Math.PI) / states.length;

                states.forEach((state, index) => {
                    const angle = index * angleStep;
                    const x = centerX + radius * Math.cos(angle) - 25;
                    const y = centerY + radius * Math.sin(angle) - 25;
                    
                    const stateElement = document.createElement('div');
                    stateElement.className = 'state';
                    stateElement.textContent = state;
                    stateElement.dataset.state = state;
                    stateElement.style.left = `${x}px`;
                    stateElement.style.top = `${y}px`;
                    
                    if (state === initialState) stateElement.classList.add('initial');
                    if (finalStates.includes(state)) stateElement.classList.add('final');
                    
                    stateElement.addEventListener('mousedown', startDrag);
                    diagramContainer.appendChild(stateElement);
                    stateElements[state] = stateElement;
                });
            }

            function drawTransitions() {
                // Group transitions by from-to pairs
                const transitionGroups = {};
                transitions.forEach(t => {
                    const key = `${t.from}-${t.to}`;
                    if (!transitionGroups[key]) transitionGroups[key] = [];
                    transitionGroups[key].push(t.input);
                });

                // Draw each transition group
                for (const [key, symbols] of Object.entries(transitionGroups)) {
                    const [from, to] = key.split('-');
                    if (from === to) {
                        drawSelfLoop(from, symbols.join(','));
                    } else {
                        drawTransitionBetweenStates(from, to, symbols.join(','));
                    }
                }
            }

            function drawTransitionBetweenStates(from, to, label) {
                const fromElement = stateElements[from];
                const toElement = stateElements[to];

                if (!fromElement || !toElement) return;

                // Get positions relative to container
                const fromRect = fromElement.getBoundingClientRect();
                const toRect = toElement.getBoundingClientRect();
                const containerRect = diagramContainer.getBoundingClientRect();

                const fromX = fromRect.left - containerRect.left + fromRect.width / 2;
                const fromY = fromRect.top - containerRect.top + fromRect.height / 2;
                const toX = toRect.left - containerRect.left + toRect.width / 2;
                const toY = toRect.top - containerRect.top + toRect.height / 2;

                // Calculate angle between states
                const angle = Math.atan2(toY - fromY, toX - fromX);
                const radius = 25; // State circle radius

                // Calculate start and end points (on the circumference)
                const startX = fromX + radius * Math.cos(angle);
                const startY = fromY + radius * Math.sin(angle);
                const endX = toX - radius * Math.cos(angle);
                const endY = toY - radius * Math.sin(angle);

                // Create SVG for the transition path
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                svg.setAttribute("width", "100%");
                svg.setAttribute("height", "100%");
                svg.style.position = "absolute";
                svg.style.left = "0";
                svg.style.top = "0";
                svg.style.pointerEvents = "none";
                svg.style.zIndex = "5";

                // Create curved path
                const path = document.createElementNS(svgNS, "path");
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                const controlX = midX + (endY - startY) * 0.2;
                const controlY = midY - (endX - startX) * 0.2;

                path.setAttribute("d", `M${startX},${startY} Q${controlX},${controlY} ${endX},${endY}`);
                path.setAttribute("fill", "none");
                path.setAttribute("stroke", "#333");
                path.setAttribute("stroke-width", "2");
                svg.appendChild(path);

                // Create arrowhead
                const arrowSize = 10;
                const arrowAngle = Math.atan2(endY - controlY, endX - controlX);
                const arrowX = endX - (radius - 5) * Math.cos(arrowAngle);
                const arrowY = endY - (radius - 5) * Math.sin(arrowAngle);

                const arrow = document.createElementNS(svgNS, "path");
                arrow.setAttribute("d", `M0,0 L${-arrowSize},${-arrowSize/2} L${-arrowSize},${arrowSize/2} Z`);
                arrow.setAttribute("transform", `translate(${arrowX},${arrowY}) rotate(${arrowAngle * 180 / Math.PI})`);
                arrow.setAttribute("fill", "#333");
                svg.appendChild(arrow);

                diagramContainer.appendChild(svg);

                // Add transition label
                const labelElement = document.createElement('div');
                labelElement.className = 'transition-label';
                labelElement.textContent = label;
                labelElement.style.left = `${controlX - 15}px`;
                labelElement.style.top = `${controlY - 10}px`;
                diagramContainer.appendChild(labelElement);
            }

            function drawSelfLoop(state, label) {
                const stateElement = stateElements[state];
                if (!stateElement) return;

                const rect = stateElement.getBoundingClientRect();
                const containerRect = diagramContainer.getBoundingClientRect();

                const x = rect.left - containerRect.left + rect.width / 2;
                const y = rect.top - containerRect.top + rect.height / 2;

                // Create SVG for the self-loop
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                svg.setAttribute("width", "100%");
                svg.setAttribute("height", "100%");
                svg.style.position = "absolute";
                svg.style.left = "0";
                svg.style.top = "0";
                svg.style.pointerEvents = "none";
                svg.style.zIndex = "5";

                // Create circular path
                const loopRadius = 30;
                const loop = document.createElementNS(svgNS, "path");
                loop.setAttribute("d", `M${x},${y - 25} A${loopRadius},${loopRadius} 0 1 1 ${x},${y - 25 - 0.1}`);
                loop.setAttribute("fill", "none");
                loop.setAttribute("stroke", "#333");
                loop.setAttribute("stroke-width", "2");
                svg.appendChild(loop);

                // Create arrowhead
                const arrow = document.createElementNS(svgNS, "path");
                arrow.setAttribute("d", "M0,0 L-10,-5 L-10,5 Z");
                arrow.setAttribute("transform", `translate(${x - 10},${y - 25 - loopRadius - 5})`);
                arrow.setAttribute("fill", "#333");
                svg.appendChild(arrow);

                diagramContainer.appendChild(svg);

                // Add label
                const labelElement = document.createElement('div');
                labelElement.className = 'transition-label';
                labelElement.textContent = label;
                labelElement.style.left = `${x - 15}px`;
                labelElement.style.top = `${y - 25 - loopRadius - 25}px`;
                diagramContainer.appendChild(labelElement);
            }

            function generateTransitionTable() {
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                
                // Create header row
                const headerRow = document.createElement('tr');
                const emptyHeader = document.createElement('th');
                headerRow.appendChild(emptyHeader);
                
                alphabet.forEach(symbol => {
                    const th = document.createElement('th');
                    th.textContent = symbol;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Create table rows for each state
                states.forEach(state => {
                    const row = document.createElement('tr');
                    const stateHeader = document.createElement('th');
                    
                    // Mark initial and final states
                    let stateLabel = state;
                    if (state === initialState) stateLabel = 'â†’ ' + stateLabel;
                    if (finalStates.includes(state)) stateLabel += ' *';
                    
                    stateHeader.textContent = stateLabel;
                    row.appendChild(stateHeader);

                    // Add transition cells for each symbol
                    alphabet.forEach(symbol => {
                        const cell = document.createElement('td');
                        const transition = transitions.find(t => t.from === state && t.input === symbol);
                        cell.textContent = transition ? transition.to : '-';
                        row.appendChild(cell);
                    });

                    tbody.appendChild(row);
                });

                table.appendChild(tbody);
                transitionTableDiv.innerHTML = '';
                transitionTableDiv.appendChild(table);
            }

            function arrangeStates() {
                if (states.length === 0) return;
                
                const containerWidth = diagramContainer.clientWidth;
                const containerHeight = diagramContainer.clientHeight;
                const centerX = containerWidth / 2;
                const centerY = containerHeight / 2;
                const radius = Math.min(containerWidth, containerHeight) * 0.35;
                const angleStep = (2 * Math.PI) / states.length;
                
                states.forEach((state, index) => {
                    const angle = index * angleStep;
                    const x = centerX + radius * Math.cos(angle) - 25;
                    const y = centerY + radius * Math.sin(angle) - 25;
                    
                    const stateElement = stateElements[state];
                    if (stateElement) {
                        stateElement.style.left = `${x}px`;
                        stateElement.style.top = `${y}px`;
                    }
                });
                
                clearTransitions();
                drawTransitions();
            }

            function clearDiagram() {
                diagramContainer.innerHTML = '';
                transitionTableDiv.innerHTML = '';
                stateElements = {};
            }

            function clearTransitions() {
                const transitions = diagramContainer.querySelectorAll('svg, .transition-label');
                transitions.forEach(t => t.remove());
            }

            function startDrag(e) {
                if (e.button !== 0) return;
                
                isDragging = true;
                draggedElement = e.target;
                dragStartX = e.clientX - draggedElement.getBoundingClientRect().left;
                dragStartY = e.clientY - draggedElement.getBoundingClientRect().top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                e.preventDefault();
            }

            function drag(e) {
                if (!isDragging) return;
                
                const containerRect = diagramContainer.getBoundingClientRect();
                let x = e.clientX - containerRect.left - dragStartX;
                let y = e.clientY - containerRect.top - dragStartY;
                
                // Constrain to container bounds
                x = Math.max(0, Math.min(x, containerRect.width - draggedElement.offsetWidth));
                y = Math.max(0, Math.min(y, containerRect.height - draggedElement.offsetHeight));
                
                draggedElement.style.left = `${x}px`;
                draggedElement.style.top = `${y}px`;
                
                clearTransitions();
                drawTransitions();
            }

            function stopDrag() {
                isDragging = false;
                draggedElement = null;
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', stopDrag);
            }

            // Initialize with default diagram
            generateDiagram();
        });
    </script>
</body>
</html>